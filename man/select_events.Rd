% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/create_distribution.R
\name{select_events}
\alias{select_events}
\title{Function to select simulated perimeters}
\usage{
select_events(
  event_surfaces,
  event_probabilities,
  target_hist,
  bins,
  reference_surface,
  surface_threshold,
  tolerance,
  max_it = 5,
  logaritmic = T
)
}
\arguments{
\item{event_surfaces}{Numeric vector of surface values for all available
simulated events.}

\item{event_probabilities}{Numeric vector of probabilities corresponding to each event in `event_surfaces`.
These probabilities are used to influence the selection of events within each bin.}

\item{target_hist}{Numeric vector representing the density of the target histogram distribution.}

\item{bins}{Numeric vector of bin breakpoints used for classifying event surfaces and calculating histograms.}

\item{reference_surface}{Numeric value representing the total target surface area that the selected events should approximate.}

\item{surface_threshold}{Numeric value between 0 and 1. The selection process
continues until the cumulative surface area of selected events is at least
`reference_surface * surface_threshold`.}

\item{tolerance}{Numeric value. A tolerance level for the final discrepancy. (Note:
the current implementation finds the best discrepancy, not necessarily stopping
once tolerance is met, but aims for the minimum).}

\item{max_it}{Integer for the maximum number of iterations for the inner loop (default: 100).}

\item{logaritmic}{Logical. If `TRUE`, a logarithmic transformation is applied
to `event_surfaces` before binning and to `selected_surfaces` for histogram
calculations (default: `TRUE`).}
}
\value{
A list containing the best selection found across all iterations:
  \describe{
    \item{selected_surfaces}{Numeric vector of surface values of the events in the best selection.}
    \item{surface_index}{Integer vector of the original indices (from `event_surfaces`)
      of the events in the best selection.}
    \item{total_surface}{Numeric value. The sum of surface areas of the events in the best selection.}
    \item{final_discrepancy}{Numeric value. The relative discrepancy between the
      selected events' distribution and the target histogram for the best selection.}
  }
  Returns `NULL` if no valid selection could be made (e.g., no valid results after iterations).
}
\description{
Selects a subset of simulated fire perimeters by matching their surface
distribution to a predefined target histogram. The selection is iterative
and probabilistic, aiming to minimize the discrepancy while accumulating
a total surface area above a certain threshold.
}
\examples{
\dontrun{
# This example requires the 'foreach' package and a parallel backend (e.g., 'doParallel')
# to be set up.
# library(doParallel)
# registerDoParallel(cores = 2) # Use 2 cores for example purposes

# Dummy data for demonstration (replace with your actual data)
event_surfaces_example <- c(10, 20, 30, 40, 50, 60, 70, 80, 90, 100,
                            110, 120, 130, 140, 150, 160, 170, 180, 190, 200)
event_probabilities_example <- rep(1/length(event_surfaces_example),
                                   length(event_surfaces_example))
reference_surface_example <- 800
surface_threshold_example <- 0.9
tolerance_example <- 0.05

# Create a dummy target histogram (assuming 'event_surfaces' from historical data)
# For a real scenario, 'event_surfaces' here would be your historical fire sizes.
historical_data_for_target <- c(5, 15, 25, 35, 45, 55, 65, 75, 85, 95,
                                105, 115, 125, 135, 145, 155, 165, 175, 185, 195)
target_info_example <- build_target_hist(num_bins = 10, l = TRUE,
                                         sizes = historical_data_for_target)
target_hist_example <- target_info_example$target_hist
bins_example <- target_info_example$bins

# Run the selection process
selected_events_result <- select_events(
  event_surfaces = event_surfaces_example,
  event_probabilities = event_probabilities_example,
  target_hist = target_hist_example,
  bins = bins_example,
  reference_surface = reference_surface_example,
  surface_threshold = surface_threshold_example,
  tolerance = tolerance_example,
  max_it = 50 # Reduced iterations for example
)

if (!is.null(selected_events_result)) {
  print(paste("Total selected surface:", selected_events_result$total_surface))
  print(paste("Final discrepancy:", selected_events_result$final_discrepancy))
  # You can further analyze selected_events_result$selected_surfaces
}

# Stop the parallel cluster when done
# stopImplicitCluster()
}
}
