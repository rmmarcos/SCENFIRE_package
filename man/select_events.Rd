% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/create_distribution.R
\name{select_events}
\alias{select_events}
\title{Function to select simulated perimeters}
\usage{
select_events(
  event_sizes,
  event_probabilities,
  target_hist,
  bins,
  reference_surface,
  surface_threshold,
  tolerance,
  max_it = 5,
  logaritmic = T
)
}
\arguments{
\item{event_sizes}{Numeric vector of surface values for all available
simulated events.}

\item{event_probabilities}{Numeric vector of probabilities corresponding to each event in `event_surfaces`.
These probabilities are used to influence the selection of events within each bin.}

\item{target_hist}{Numeric vector representing the density of the target histogram distribution.}

\item{bins}{Numeric vector of bin breakpoints used for classifying event surfaces and calculating histograms.}

\item{reference_surface}{Numeric value representing the total target surface area that the selected events should approximate.}

\item{surface_threshold}{Numeric value between 0 and 1. The selection process
continues until the cumulative surface area of selected events is at least
`reference_surface * surface_threshold`.}

\item{tolerance}{Numeric value. A tolerance level for the final discrepancy. (Note:
the current implementation finds the best discrepancy, not necessarily stopping
once tolerance is met, but aims for the minimum).}

\item{max_it}{Integer for the maximum number of iterations for the inner loop (default: 100).}

\item{logaritmic}{Logical. If `TRUE`, a logarithmic transformation is applied
to `event_surfaces` before binning and to `selected_surfaces` for histogram
calculations (default: `TRUE`).}
}
\value{
A list containing the best selection found across all iterations:
  \describe{
    \item{selected_surfaces}{Numeric vector of surface values of the events in the best selection.}
    \item{surface_index}{Integer vector of the original indices (from `event_surfaces`)
      of the events in the best selection.}
    \item{total_surface}{Numeric value. The sum of surface areas of the events in the best selection.}
    \item{final_discrepancy}{Numeric value. The relative discrepancy between the
      selected events' distribution and the target histogram for the best selection.}
  }
  Returns `NULL` if no valid selection could be made (e.g., no valid results after iterations).
}
\description{
Selects a subset of simulated fire perimeters by matching their surface
distribution to a predefined target histogram. The selection is iterative
and probabilistic, aiming to minimize the discrepancy while accumulating
a total surface area above a certain threshold.
}
\examples{
\dontrun{
# This example requires the 'foreach' package and a parallel backend (e.g., 'doParallel')
# to be set up.
# library(doParallel)

# Dummy data for demonstration (replace with your actual data)
set.seed(123)
historical_data_for_target <- floor(fit_powerlaw(n = 500, alpha = 2, xmin = 10, xmax = 10000))
event_surfaces <- fit_powerlaw(n = 10000, alpha = 2, xmin = 10, xmax = 10000)
# Discard simulated fires that are too large (below 110\% max historical size)
event_surfaces <- event_surfaces[event_surfaces<max(historical_data_for_target)*1.1]
event_probabilities <- rnorm(length(event_surfaces))
event_probabilities <- (event_probabilities-min(event_probabilities))/(max(event_probabilities)-min(event_probabilities))

y <- 100 #number of years spanning historical fire data
check_fire_data(fires_hist_size = historical_data_for_target,
                sim_perimeters_size = event_surfaces,
                n_years = y)

reference_surface_example <- sum(historical_data_for_target)/y
surface_threshold_example <- check_fire_data(fires_hist_size = historical_data_for_target,
                                             sim_perimeters_size = event_surfaces,
                                             n_years = 10)
tolerance_example <- 0.1

# Create a dummy target histogram (assuming 'event_surfaces' from historical data)
# For a real scenario, 'event_surfaces' here would be your historical fire sizes.

target_info_example <- build_target_hist(num_bins = 10, logaritmic = TRUE,
                                         sizes = historical_data_for_target,
                                         event_surfaces = event_surfaces)
target_hist <- target_info_example$target_hist
bins <- target_info_example$bins

# Run the selection process
selected_events_result <- select_events(
  event_sizes = event_surfaces,
  event_probabilities = event_probabilities,
  target_hist = target_hist,
  bins = bins,
  reference_surface = reference_surface_example,
  surface_threshold = surface_threshold_example,
  tolerance = tolerance_example,
  max_it = 2 # Reduced iterations for example
)

visualize_selected_dist(result = selected_events_result)

# Stop the parallel cluster when done
# stopImplicitCluster()
}
}
